// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model for authentication and user data
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  clerkId   String   @unique // Clerk user ID
  firstName String?
  lastName  String?
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // User preferences
  checkinDay  String? // e.g., "Monday", "Tuesday", etc.
  checkinTime String? // e.g., "09:00 AM", "10:00 AM", etc.
  timezone    String? @default("UTC")
  
  // Relations
  whispers      Whisper[]
  tags          Tag[]
  checkins      WeeklyCheckin[]
  usageLimits   UsageLimit[]
  
  @@index([clerkId])
  @@index([email])
}

// Main transcription/audio recording model
model Whisper {
  id                String   @id @default(uuid())
  title             String
  fullTranscription String   @db.Text
  userId            String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relations
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  audioTracks     AudioTrack[]
  transformations Transformation[]
  tags            Tag[]
  
  @@index([userId])
  @@index([createdAt])
  @@index([userId, createdAt])
}

// Individual audio file/segment
model AudioTrack {
  id                   String   @id @default(uuid())
  fileUrl              String
  partialTranscription String   @db.Text
  language             String?  @default("en")
  whisperId            String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  // Relations
  whisper Whisper @relation(fields: [whisperId], references: [id], onDelete: Cascade)
  
  @@index([whisperId])
  @@index([createdAt])
}

// AI-generated transformations (summaries, notes, etc.)
model Transformation {
  id           String   @id @default(uuid())
  typeName     String   // e.g., "summary", "notes", "action_items"
  text         String   @db.Text
  isGenerating Boolean  @default(false)
  whisperId    String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Relations
  whisper Whisper @relation(fields: [whisperId], references: [id], onDelete: Cascade)
  
  @@index([whisperId])
  @@index([typeName])
  @@index([whisperId, typeName])
}

// Tags for categorizing transcriptions
model Tag {
  id        String   @id @default(uuid())
  name      String
  whisperId String
  userId    String   // For security and user-specific operations
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  whisper Whisper @relation(fields: [whisperId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Constraints and indexes
  @@unique([whisperId, name]) // Prevent duplicate tag names per whisper
  @@index([userId])
  @@index([whisperId])
  @@index([name])
  @@index([userId, name])
}

// Weekly check-ins for accountability
model WeeklyCheckin {
  id               String   @id @default(uuid())
  userId           String
  scheduledDay     String   // e.g., "Monday"
  scheduledTime    String   // e.g., "09:00 AM"
  actualCheckinAt  DateTime?
  status           CheckinStatus @default(SCHEDULED)
  goals            String?  @db.Text
  achievements     String?  @db.Text
  challenges       String?  @db.Text
  nextWeekPlan     String?  @db.Text
  weekStartDate    DateTime // Start of the week this checkin is for
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, weekStartDate]) // One checkin per user per week
  @@index([userId])
  @@index([status])
  @@index([weekStartDate])
  @@index([userId, status])
}

// Usage limits for API calls, minutes, etc.
model UsageLimit {
  id        String   @id @default(uuid())
  userId    String
  limitType String   // e.g., "audio_minutes", "transformations", "api_calls"
  used      Int      @default(0)
  limit     Int
  resetDate DateTime // When the limit resets (daily/monthly)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, limitType])
  @@index([userId])
  @@index([limitType])
  @@index([resetDate])
}

// Enums
enum CheckinStatus {
  SCHEDULED
  COMPLETED
  MISSED
  RESCHEDULED
}