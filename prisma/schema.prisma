generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Whisper {
  id                String           @id @default(uuid())
  title             String
  userId            String
  createdAt         DateTime         @default(now())
  fullTranscription String
  audioTracks       AudioTrack[]
  transformations   Transformation[]
  tags              Tag[]
}

model Transformation {
  id           String   @id @default(uuid())
  whisperId    String
  isGenerating Boolean  @default(true)
  typeName     String
  text         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  whisper      Whisper  @relation(fields: [whisperId], references: [id])
}

model Tag {
  id        String   @id @default(uuid())
  name      String
  whisperId String
  userId    String   // For security and user-specific operations
  color     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  whisper   Whisper  @relation(fields: [whisperId], references: [id], onDelete: Cascade)
   
  transcriptions TranscriptionTag[]
  
  // Indexes and constraints
  @@unique([whisperId, name]) // Prevent duplicate tag names per whisper
  @@index([userId])
  @@index([whisperId])
  @@index([name])
}

model AudioTrack {
  id                   String   @id @default(uuid())
  fileUrl              String
  partialTranscription String
  createdAt            DateTime @default(now())
  whisperId            String
  language             String?
  whisper              Whisper  @relation(fields: [whisperId], references: [id])
}


model User {
  id                      String    @id @default(cuid())
  email                   String    @unique
  firstName               String?
  lastName               String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  
  // Subscription fields
  subscriptionPlan        String    @default("free") // 'free', 'monthly', 'annual', 'lifetime'
  subscriptionStatus      String    @default("inactive") // 'active', 'inactive', 'cancelled', 'expired'
  subscriptionBillingCycle String? // 'monthly', 'yearly', 'once'
  subscriptionAmount      Float?
  subscriptionStartDate   DateTime?
  subscriptionEndDate     DateTime?
  stripeCustomerId        String? @unique
  
  // Relations
  transactions           Transaction[]
  subscriptionHistory    SubscriptionHistory[]
  
  @@map("users")
  WeeklyCheckin WeeklyCheckin[]
  UsageLimit UsageLimit[]
}

model Transaction {
  id                    String    @id @default(cuid())
  userId                String
  stripePaymentIntentId String    @unique
  stripeCustomerId      String?
  
  // Payment details
  amount                Float
  currency              String    @default("usd")
  status                String    // 'pending', 'completed', 'failed', 'refunded'
  
  // Plan details
  planType              String    // 'monthly', 'annual', 'lifetime'
  billingCycle          String    // 'monthly', 'yearly', 'once'
  originalPrice         Float?
  finalPrice            Float
  
  // Coupon information
  couponCode            String?
  discountAmount        Float     @default(0)
  discountType          String?   // 'percentage', 'fixed'
  
  // Metadata as JSON
  metadata              Json?
  
  // Timestamps
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  paymentDate           DateTime?
  
  // Relations
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptionHistory   SubscriptionHistory[]
  
  @@map("transactions")
}

model SubscriptionHistory {
  id            String    @id @default(cuid())
  userId        String
  transactionId String?
  
  // Subscription details
  planType      String
  status        String    // 'active', 'cancelled', 'expired', 'paused'
  billingCycle  String?
  amount        Float?
  
  // Dates
  startDate     DateTime
  endDate       DateTime?
  
  // Timestamps
  createdAt     DateTime  @default(now())
  
  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  transaction   Transaction? @relation(fields: [transactionId], references: [id])
  
  @@map("subscription_history")
}

model CouponUsage {
  id          String   @id @default(cuid())
  userId      String
  couponCode  String
  createdAt   DateTime @default(now())
  
  @@index([userId])
  @@index([couponCode])
}

model CouponValidation {
  id              String   @id @default(cuid())
  userId          String
  couponCode      String
  planType        String
  originalPrice   Float
  discountedPrice Float
  successful      Boolean
  ipAddress       String
  userAgent       String
  errorMessage    String?
  createdAt       DateTime @default(now())
}

model Subscription {
  id             String     @id @default(cuid())
  userId         String     @unique
  plan           String     @default("free") // e.g., "free", "pro", "premium"
  recordingLimit Int        @default(60) // in seconds
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  @@index([userId])
}

model DailyUsage {
  id          String   @id @default(cuid())
  userId      String
  date        String   // Format: "YYYY-MM-DD"
  usedSeconds Int      @default(0)
  createdAt   DateTime @default(now())

  @@unique([userId, date])
  @@index([userId])
}

model Transcription {
  id          String   @id @default(cuid())
  userId      String
  title       String
  preview     String
  content     String
  timestamp   String
  date        String?
  time        String?
  duration    String?
  language    String?
  confidence  Float?
  createdAt   DateTime @default(now())
  
  // Relations
  tags        TranscriptionTag[]
  transforms  String[] // Array of transform names/types
  
  @@index([userId])
  @@index([createdAt])
}

// Junction table for many-to-many relationship with tags
model TranscriptionTag {
  id             String        @id @default(cuid())
  transcriptionId String
  tagId          String
  
  transcription  Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)
  tag            Tag          @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([transcriptionId, tagId])
}


model RecordingLog {
  id          String   @id @default(cuid())
  userId      String
  duration    Int      // in seconds
  plan        String
  timestamp   DateTime @default(now())
  
  @@index([userId])
  @@index([timestamp])
}



// Weekly check-ins for accountability
model WeeklyCheckin {
  id               String   @id @default(uuid())
  userId           String
  scheduledDay     String   // e.g., "Monday"
  scheduledTime    String   // e.g., "09:00 AM"
  actualCheckinAt  DateTime?
  status           CheckinStatus @default(SCHEDULED)
  goals            String?  @db.Text
  achievements     String?  @db.Text
  challenges       String?  @db.Text
  nextWeekPlan     String?  @db.Text
  weekStartDate    DateTime // Start of the week this checkin is for
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, weekStartDate]) // One checkin per user per week
  @@index([userId])
  @@index([status])
  @@index([weekStartDate])
  @@index([userId, status])
}

// Usage limits for API calls, minutes, etc.
model UsageLimit {
  id        String   @id @default(uuid())
  userId    String
  limitType String   // e.g., "audio_minutes", "transformations", "api_calls"
  used      Int      @default(0)
  limit     Int
  resetDate DateTime // When the limit resets (daily/monthly)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, limitType])
  @@index([userId])
  @@index([limitType])
  @@index([resetDate])
}

// Enums
enum CheckinStatus {
  SCHEDULED
  COMPLETED
  MISSED
  RESCHEDULED
}